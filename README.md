# aws-vms-exercise

## Overview - AWS
This setup creates a VPC (with all necessary components for connectivity), VMs, SG and then runs a ping in a round-robin fashion between each one, starting from the first one created and then logs the results in a Terraform output variable.

## How it works
1. Terraform creates the resources in AWS (VPC, SG, EC2). It uses `user_data` via a Cloud-init template to set SSH password generated by the `random_password` resource, turns on SSH password authentication on the VM.
2. It then uses the `remote-exec` provisioner to SSH from one VM to the other using the randomly generated password, starting with the first one, uses ping to send 3 packets and then outputting the result into `/tmp/*.log` on the remote VMs.
3. It then uses the `local-exec` provisioner and `sshpass` to copy the log files from the remote machine, locally.
4. It then uses the `local-exec` provisioner to aggregate all log files saved locally into `aggregated.log`.
5. Then it uses a data external source to run a script (`check_ping_results.sh`) that checks if pings were were successful or not and gives a FAIL/PASS. This is then outputted to JSON via `jq`. This references the FAIL/PASS result in the data external source to be set as a Terraform output variable.
6. Then it uses a data external source to run another script (`read_log.sh`) to read `aggregated.log` file, output the content to JSON via `jq`. This references the content of the log file in the data source and its then set as a Terraform output variable, so it shows the ping operation from each VM.


## Prerequisites
- Terraform (v1.9.0 or older)
- AWS credentials configured (AWS profile)
- S3 bucket set up for remote state
- Dependencies (sshpass, jq, make)

## Terraform Configuration

### Files
- `main.tf`: Root module where VMs are created and where ping logic is done
- `networking.tf`: Definition for VPC and components necessary for connectivity between VMs
- `sg.tf`: Definition for SG to enable SSH and ICMP
- `ping_results.tf`: Configuration for aggregating ping results
- `variables.tf`: Definition of input variables
- `outputs.tf`: Definition of output variables
- `backend.tf`: Definition for storing tfstate file in S3
- `providers.tf`: Definition of providers

### Modules
- `modules/vm`: Used to create multiple VMs

### Variables
Variables to be set up in tfvars in the env folder.

#### terraform.tfvars
- `project`: Project name
- `env`: Environment
- `profile`: AWS profile
- `region`: Region
- `vpc_cidr_block`: VPC CIDR block
- `subnet_cidr_block`: Subnet CIDR block
- `availability_zone`: Availability Zone
- `instance_count`: Number of VM instances to create
- `ami`: AMI (image flavor) for VMs
- `instance_type`: Instance type for VMs

#### backend.tfvars
- `bucket` - S3 bucket name
- `key` - tfstate location
- `region` - Region
- `profile` - AWS profile

### Resources
AWS resources created by this Terraform configuration:
- VPC (subnet, route table, internet gateway)
- EC2 instances
- Security group for SSH and ICMP

### Provisioners
- `remote-exec`: Used for executing commands on remote VMs
- `local-exec`: Used for executing commands locally after remote operations

### Scripts
Located in `./scripts`
- `check_ping_results.sh`: Does the FAIL/PASS logic, outputs it to JSON and references it into a data external source
- `read_log.sh`: Reads `aggregated.log`, outputs it to JSON and references it into a data external source

## Execution

### Steps to Deploy
1. Clone the repository.
2. Replace `profile` variable in `backend.tfvars` and `terraform.tfvars` with your AWS profile.
3. Set up environment with `export TF_ENVIRONMENT=staging`. By default, if no value is set, `staging` is used.
4. Initialize Terraform with `make init`.
5. Review and validate the plan with `make plan`.
6. Apply the configuration with `make apply`.
7. Destroy the resources with `make destroy`.

### Outputs
- `ping_results`: Ping results
- `ping_status`: FAIL/PASS for pings
- `public_ips`: Public IPs of the VMs
- `admin_passwords`: SSH user password (sensitive)